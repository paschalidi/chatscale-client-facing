{"version":3,"sources":["/Users/christos/dev/next-chat-project/packages/react/dist/index.mjs","../src/context/ChatContext/index.tsx","../src/context/ChatContext/useChannels.ts","../src/lib/logError.ts","../src/config.ts","../src/lib/apiRequest.ts","../src/services/index.ts","../src/context/ChatContext/useWebsocket.ts","../src/context/ChatContext/useChannelMessage.ts","../src/components/ChannelList/index.tsx","../src/components/MessageInput/index.tsx","../src/components/Messages/index.tsx","../../../node_modules/clsx/dist/clsx.mjs"],"names":["React","useMemo","useEffect","useState","logError","error","additionalContext","message","stack","Error","String","errorLog","timestamp","Date","toISOString","console","config","rust_api_url","rust_ws_url","apiRequest","path","fetchOptions","serverOptions","defaultHeaders","serverUrl","url","response","contentType","errorData","fetch","headers","get","ok","includes","JSON","status","stringify","body","json","logErrorMetadata","context","name","fetchChannels","method","Accept","postMessage","fetchMessagesByChannelId","channelId","useChannels","channelName","data","setData","isLoading","setIsLoading","setError","fetchData","err","currentChannelId","find","channel","id","channels","isChannelsLoading","channelsError","refetchChannels","useRef","useWebSocket","isConnected","setIsConnected","messages","setMessages","ws","connect","log","current","readyState","WebSocket","onopen","onmessage","event","parse","prev","participant_id","channel_name","content","onclose","OPEN","close","useCallback","useChannelMessages","fetchMessages","areMessagesLoading","messagesError","refetchMessages","ChatContext","createContext","ChatProvider","children","organizationToken","userId","userName","options","reconnectInterval","maxReconnectAttempts","debug","wsMessages","channelMessages","value","currentUser","activeChannel","refetch","wsEndpoint","createElement","Provider","useChat","useContext","ChannelList","limit","onChatSelect","customStyles","renderItem","React2","className","container","map","key","onClick","chatItem","MessageInput","placeholder","onSend","maxLength","disabled","React3","setMessage","currentUserId","handleSubmit","e","preventDefault","trim","send","onSubmit","type","onChange","target","r","t","f","n","Array","isArray","o","length","clsx","arguments","Messages","containerClassName","messageClassName","renderMessage","messagesEndRef","React4","scrollToBottom","scrollIntoView","behavior","defaultRenderMessage","toString","index","ref"],"mappings":"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","sourcesContent":["// src/context/ChatContext/index.tsx\nimport * as React from \"react\";\nimport { useMemo } from \"react\";\n\n// src/context/ChatContext/useChannels.ts\nimport { useEffect, useState } from \"react\";\n\n// src/lib/logError.ts\nvar logError = (error, additionalContext = {}) => {\n  let message;\n  let stack;\n  if (error instanceof Error) {\n    message = error.message;\n    stack = error.stack;\n  } else {\n    message = String(error);\n    stack = void 0;\n  }\n  const errorLog = {\n    message,\n    stack,\n    timestamp: (/* @__PURE__ */ new Date()).toISOString(),\n    ...additionalContext\n  };\n  console.error(errorLog);\n};\n\n// src/config.ts\nvar config = {\n  rust_api_url: \"https://api.rechat.cloud\",\n  rust_ws_url: \"wss://api.rechat.cloud/ws\"\n};\n\n// src/lib/apiRequest.ts\nasync function apiRequest(path, fetchOptions = {}, serverOptions = {}) {\n  const defaultHeaders = {\n    \"Content-Type\": \"application/json\"\n  };\n  const { serverUrl = config.rust_api_url } = serverOptions;\n  const url = `${serverUrl}${path}`;\n  try {\n    const response = await fetch(url, {\n      ...fetchOptions,\n      headers: {\n        ...defaultHeaders,\n        ...fetchOptions.headers\n      }\n    });\n    const contentType = response.headers.get(\"content-type\");\n    if (!response.ok) {\n      if (!contentType || !contentType.includes(\"application/json\")) {\n        throw new Error(\n          `${url} <- Error ${response.status}: Invalid content-type. Expected application/json, got ${JSON.stringify(response.body)}`\n        );\n      }\n      const errorData = await response.json();\n      throw new Error(\n        `${url} <- Error ${response.status}: ${JSON.stringify(\n          errorData,\n          null,\n          2\n        )} `\n      );\n    }\n    if (response.status === 204) {\n      return { status: \"204\" };\n    }\n    return await response.json();\n  } catch (error) {\n    if (error instanceof Error) {\n      logErrorMetadata(error, url);\n    } else {\n      logError(error, { context: \"Unexpected Error\", url });\n    }\n    throw error;\n  }\n}\nvar logErrorMetadata = (error, url) => {\n  if (error.name === \"AbortError\") {\n    logError(`Timeout \\u2013 ${error.name} ${error}`, {\n      context: \"Timeout Error\",\n      url\n    });\n  } else {\n    logError(`${error.name} ${error}`, { context: \"Fetch Error\", url });\n  }\n};\n\n// src/services/index.ts\nvar fetchChannels = async () => {\n  return await apiRequest(\n    \"/api/channels\",\n    {\n      method: \"GET\",\n      headers: {\n        Accept: \"application/json\"\n      }\n    }\n  );\n};\nvar postMessage = async (message) => {\n  return await apiRequest(\n    \"/api/messages\",\n    {\n      method: \"POST\",\n      body: JSON.stringify(message)\n    }\n  );\n};\nvar fetchMessagesByChannelId = async ({ channelId }) => {\n  return await apiRequest(\n    `/api/messages/${channelId}`,\n    {\n      method: \"GET\",\n      headers: {\n        Accept: \"application/json\"\n      }\n    }\n  );\n};\n\n// src/context/ChatContext/useChannels.ts\nvar useChannels = ({ channelName }) => {\n  const [data, setData] = useState();\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const fetchData = async () => {\n    setIsLoading(true);\n    setError(null);\n    try {\n      const { data: data2 } = await fetchChannels();\n      setData(data2);\n    } catch (err) {\n      setError(err instanceof Error ? err : new Error(\"Failed to fetch channels\"));\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  useEffect(() => {\n    fetchData();\n  }, []);\n  return {\n    currentChannelId: data?.find((channel) => channelName === channel.name)?.id,\n    channels: data,\n    isChannelsLoading: isLoading,\n    channelsError: error,\n    refetchChannels: fetchData\n  };\n};\n\n// src/context/ChatContext/useWebsocket.ts\nimport { useEffect as useEffect2, useRef, useState as useState2 } from \"react\";\nfunction useWebSocket(channelName) {\n  const [isConnected, setIsConnected] = useState2(false);\n  const [messages, setMessages] = useState2([]);\n  const ws = useRef(null);\n  useEffect2(() => {\n    const connect = () => {\n      console.log(ws.current, ws.current?.readyState);\n      console.log(\"Connecting to WebSocket the \", channelName);\n      ws.current = new WebSocket(`${config.rust_ws_url}/chat/${channelName}`);\n      ws.current.onopen = () => {\n        setIsConnected(true);\n        console.log(\"WebSocket connected\");\n      };\n      ws.current.onmessage = (event) => {\n        const data = JSON.parse(event.data);\n        setMessages((prev) => [...prev, {\n          participant_id: data.participant_id,\n          channel_name: data.channel_name,\n          content: data.content\n        }]);\n      };\n      ws.current.onclose = () => {\n        setIsConnected(false);\n        console.log(\"WebSocket closed\");\n      };\n    };\n    connect();\n    return () => {\n      if (ws.current && ws.current.readyState === WebSocket.OPEN) {\n        ws.current.close();\n      }\n    };\n  }, [channelName]);\n  return { isConnected, messages, ws: ws.current };\n}\n\n// src/context/ChatContext/useChannelMessage.ts\nimport { useCallback, useEffect as useEffect3, useState as useState3 } from \"react\";\nfunction useChannelMessages(channelId) {\n  const [messages, setMessages] = useState3([]);\n  const [isLoading, setIsLoading] = useState3(false);\n  const [error, setError] = useState3(null);\n  const fetchMessages = useCallback(async () => {\n    if (!channelId) return;\n    setIsLoading(true);\n    try {\n      const { data } = await fetchMessagesByChannelId({ channelId });\n      setMessages(data);\n    } catch (err) {\n      setError(err instanceof Error ? err : new Error(\"Failed to fetch messages\"));\n    } finally {\n      setIsLoading(false);\n    }\n  }, [channelId]);\n  useEffect3(() => {\n    fetchMessages();\n  }, [channelId, fetchMessages]);\n  return { messages, areMessagesLoading: isLoading, messagesError: error, refetchMessages: fetchMessages };\n}\n\n// src/context/ChatContext/index.tsx\nvar ChatContext = React.createContext(null);\nvar ChatProvider = ({\n  children,\n  organizationToken,\n  channelName,\n  userId,\n  userName = \"Unknown user\",\n  options = {\n    reconnectInterval: 3e3,\n    maxReconnectAttempts: 5,\n    debug: false\n  }\n}) => {\n  const { isConnected, messages: wsMessages, ws } = useWebSocket(channelName);\n  const {\n    channels,\n    isChannelsLoading,\n    channelsError,\n    refetchChannels,\n    currentChannelId\n  } = useChannels({ channelName });\n  const {\n    messages: channelMessages,\n    areMessagesLoading,\n    refetchMessages,\n    messagesError\n  } = useChannelMessages(currentChannelId);\n  const value = useMemo(() => ({\n    organizationToken,\n    currentUser: {\n      id: userId,\n      userName,\n      isConnected\n    },\n    activeChannel: {\n      name: channelName,\n      id: currentChannelId\n    },\n    channels: {\n      data: channels,\n      isLoading: isChannelsLoading,\n      error: channelsError,\n      refetch: refetchChannels\n    },\n    messages: {\n      data: [...channelMessages || [], ...wsMessages || []],\n      isLoading: areMessagesLoading,\n      error: messagesError,\n      refetch: refetchMessages\n    },\n    wsEndpoint: `${config.rust_ws_url}/chat/${channelName}`,\n    ws\n  }), [\n    organizationToken,\n    channelName,\n    currentChannelId,\n    isConnected,\n    channelMessages,\n    wsMessages,\n    areMessagesLoading,\n    messagesError,\n    refetchMessages,\n    ws,\n    userId,\n    userName,\n    channels,\n    isChannelsLoading,\n    channelsError,\n    refetchChannels\n  ]);\n  return /* @__PURE__ */ React.createElement(ChatContext.Provider, { value }, children);\n};\nvar useChat = () => {\n  const context = React.useContext(ChatContext);\n  if (!context) {\n    throw new Error(\"useChat must be used within a ChatProvider\");\n  }\n  return context;\n};\n\n// src/components/ChannelList/index.tsx\nimport * as React2 from \"react\";\nvar ChannelList = ({\n  limit = 50,\n  onChatSelect,\n  customStyles = {},\n  renderItem\n}) => {\n  const { channels } = useChat();\n  if (channels.isLoading) {\n    return /* @__PURE__ */ React2.createElement(\"div\", null, \"Loading chats...\");\n  }\n  return /* @__PURE__ */ React2.createElement(\"div\", { className: customStyles.container }, channels.data?.map((channel) => /* @__PURE__ */ React2.createElement(\n    \"div\",\n    {\n      key: channel.id,\n      onClick: () => onChatSelect?.(channel),\n      className: customStyles.chatItem\n    },\n    renderItem ? renderItem(channel) : /* @__PURE__ */ React2.createElement(\"div\", null, /* @__PURE__ */ React2.createElement(\"h3\", null, channel.name))\n  )));\n};\n\n// src/components/MessageInput/index.tsx\nimport * as React3 from \"react\";\nvar MessageInput = ({\n  placeholder = \"Type a message...\",\n  onSend,\n  maxLength = 1e3,\n  disabled = false\n}) => {\n  const [message, setMessage] = React3.useState(\"\");\n  const {\n    ws,\n    currentUser: {\n      id: currentUserId,\n      isConnected\n    },\n    activeChannel: {\n      name: channelName\n    }\n  } = useChat();\n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    if (message.trim() && ws && isConnected) {\n      const data = {\n        channel_name: channelName,\n        participant_id: currentUserId,\n        content: message\n      };\n      ws.send(JSON.stringify(data));\n      onSend?.(message);\n      setMessage(\"\");\n      try {\n        await postMessage(data);\n      } catch (e2) {\n        console.error(e2);\n      }\n    }\n  };\n  return /* @__PURE__ */ React3.createElement(\"form\", { onSubmit: handleSubmit, className: \"flex gap-2\" }, /* @__PURE__ */ React3.createElement(\n    \"input\",\n    {\n      type: \"text\",\n      value: message,\n      onChange: (e) => setMessage(e.target.value),\n      placeholder,\n      maxLength,\n      disabled: disabled || !isConnected,\n      className: \"flex-1 px-3 py-2 rounded border\"\n    }\n  ), /* @__PURE__ */ React3.createElement(\n    \"button\",\n    {\n      type: \"submit\",\n      disabled: disabled || !message.trim() || !isConnected,\n      className: \"px-4 py-2 rounded disabled:opacity-50\"\n    },\n    \"Send\"\n  ));\n};\n\n// src/components/Messages/index.tsx\nimport * as React4 from \"react\";\nimport { useEffect as useEffect5 } from \"react\";\n\n// ../../node_modules/clsx/dist/clsx.mjs\nfunction r(e) {\n  var t, f, n = \"\";\n  if (\"string\" == typeof e || \"number\" == typeof e) n += e;\n  else if (\"object\" == typeof e) if (Array.isArray(e)) {\n    var o = e.length;\n    for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += \" \"), n += f);\n  } else for (f in e) e[f] && (n && (n += \" \"), n += f);\n  return n;\n}\nfunction clsx() {\n  for (var e, t, f = 0, n = \"\", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += \" \"), n += t);\n  return n;\n}\n\n// src/components/Messages/index.tsx\nvar Messages = ({\n  className = \"\",\n  containerClassName = \"\",\n  messageClassName = \"\",\n  renderMessage\n}) => {\n  const {\n    messages: { data: messages, refetch },\n    currentUser: {\n      id: currentUserId\n    }\n  } = useChat();\n  const messagesEndRef = React4.useRef(null);\n  useEffect5(() => {\n    refetch();\n  }, []);\n  const scrollToBottom = () => {\n    messagesEndRef.current?.scrollIntoView({ behavior: \"smooth\" });\n  };\n  React4.useEffect(() => {\n    scrollToBottom();\n  }, [messages]);\n  const defaultRenderMessage = (message) => {\n    return /* @__PURE__ */ React4.createElement(\n      \"div\",\n      {\n        key: message.participant_id.toString() + message.content,\n        className: clsx(\n          messageClassName,\n          \"flex flex-col max-w-[70%]\",\n          message.participant_id === currentUserId ? \"ml-auto items-end\" : \"items-start\"\n        )\n      },\n      /* @__PURE__ */ React4.createElement(\"span\", { className: \"text-xs text-muted-foreground\" }, message.participant_id === currentUserId ? \"\" : message.participant_id ?? \"Some user\"),\n      /* @__PURE__ */ React4.createElement(\n        \"div\",\n        {\n          className: clsx(\n            \"rounded-lg px-1 max-w-[90%]\",\n            message.participant_id === currentUserId ? \"bg-blue-500 text-white self-end\" : \"bg-neutral-200 text-neutral-800 self-start\"\n          )\n        },\n        /* @__PURE__ */ React4.createElement(\"p\", null, message.content)\n      )\n    );\n  };\n  return /* @__PURE__ */ React4.createElement(\"div\", { className: `flex flex-col h-full ${className}` }, /* @__PURE__ */ React4.createElement(\"div\", { className: `flex-1 overflow-y-auto p-4 space-y-4 ${containerClassName}` }, messages?.map((message, index) => /* @__PURE__ */ React4.createElement(\"div\", { key: index, className: \"max-w-[70%]\" }, renderMessage ? renderMessage(message) : defaultRenderMessage(message))), /* @__PURE__ */ React4.createElement(\"div\", { ref: messagesEndRef })));\n};\nexport {\n  ChannelList,\n  ChatProvider,\n  MessageInput,\n  Messages,\n  useChat\n};\n","import * as React from 'react';\nimport { useMemo } from 'react';\nimport { useChannels } from \"./useChannels\";\nimport { useWebSocket } from \"./useWebsocket\";\nimport { useChannelMessages } from \"./useChannelMessage\";\nimport { config } from \"../../config\";\nimport { ChannelsResponseDto, MessageRequestDto, MessageResponseDto, CombinedMessagesDto } from \"../../types\";\n\ninterface Resource<T> {\n  data: T | undefined;\n  isLoading: boolean;\n  error: Error | null;\n  refetch: () => Promise<void>;\n}\n\ninterface ChatContextType {\n  organizationToken: string;\n  activeChannel: {\n    name: string;\n    id: string | undefined;\n  }\n  currentUser: {\n    id: string;\n    userName: string;\n    isConnected: boolean;\n  }\n  wsEndpoint: string;\n  ws: WebSocket | null;\n  messages: Resource<CombinedMessagesDto>;\n  channels: Resource<ChannelsResponseDto>;\n}\n\ninterface ChatProviderProps {\n  children: React.ReactNode;\n  organizationToken: string;\n  channelName: string;\n  userId: string;\n  userName?: string;\n  options?: {\n    reconnectInterval?: number;\n    maxReconnectAttempts?: number;\n    debug?: boolean;\n  };\n}\n\n\nconst ChatContext = React.createContext<ChatContextType | null>(null);\n\nexport const ChatProvider: React.FC<ChatProviderProps> = ({\n                                                            children,\n                                                            organizationToken,\n                                                            channelName,\n                                                            userId,\n                                                            userName = 'Unknown user',\n                                                            options = {\n                                                              reconnectInterval: 3000,\n                                                              maxReconnectAttempts: 5,\n                                                              debug: false\n                                                            }\n                                                          }) => {\n  const { isConnected, messages: wsMessages, ws } = useWebSocket(channelName);\n  const {\n    channels,\n    isChannelsLoading,\n    channelsError,\n    refetchChannels,\n    currentChannelId\n  } = useChannels({ channelName });\n  const {\n    messages: channelMessages,\n    areMessagesLoading,\n    refetchMessages,\n    messagesError\n  } = useChannelMessages(currentChannelId);\n\n  const value = useMemo<ChatContextType>(() => ({\n    organizationToken,\n    currentUser: {\n      id: userId,\n      userName: userName,\n      isConnected,\n\n    },\n    activeChannel: {\n      name: channelName,\n      id: currentChannelId\n    },\n    channels: {\n      data: channels,\n      isLoading: isChannelsLoading,\n      error: channelsError,\n      refetch: refetchChannels\n    },\n    messages: {\n      data: [...(channelMessages || []), ...(wsMessages || [])],\n      isLoading: areMessagesLoading,\n      error: messagesError,\n      refetch: refetchMessages\n    },\n    wsEndpoint: `${config.rust_ws_url}/chat/${channelName}`,\n    ws,\n  }), [\n    organizationToken,\n    channelName,\n    currentChannelId,\n    isConnected,\n    channelMessages,\n    wsMessages,\n    areMessagesLoading,\n    messagesError,\n    refetchMessages,\n    ws,\n    userId,\n    userName,\n    channels,\n    isChannelsLoading,\n    channelsError,\n    refetchChannels\n  ]);\n\n  return (\n    <ChatContext.Provider value={value}>\n      {children}\n    </ChatContext.Provider>\n  );\n};\n\nexport const useChat = () => {\n  const context = React.useContext(ChatContext);\n  if (!context) {\n    throw new Error('useChat must be used within a ChatProvider');\n  }\n  return context;\n};","import { useEffect, useState } from 'react';\nimport { fetchChannels } from \"../../services\";\nimport { ChannelsResponseDto } from \"../../types\";\n\ninterface UseChannelsReturn {\n  channels: ChannelsResponseDto | undefined;\n  currentChannelId: string | undefined;\n  isChannelsLoading: boolean;\n  channelsError: Error | null;\n  refetchChannels: () => Promise<void>;\n}\n\nexport const useChannels = ({ channelName }: { channelName: string }): UseChannelsReturn => {\n  const [data, setData] = useState<ChannelsResponseDto>();\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n\n  const fetchData = async () => {\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const { data } = await fetchChannels();\n      setData(data);\n    } catch (err) {\n      setError(err instanceof Error ? err : new Error('Failed to fetch channels'));\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  useEffect(() => {\n    fetchData();\n  }, []);\n\n  return {\n    currentChannelId: data?.find(channel => channelName === channel.name)?.id,\n    channels: data,\n    isChannelsLoading: isLoading,\n    channelsError: error,\n    refetchChannels: fetchData\n  };\n};","interface ErrorLog {\n  message: string;\n  stack?: string;\n  timestamp: string;\n\n  [key: string]: any; // Additional dynamic properties\n}\n\nexport const logError = (\n  error: unknown,\n  additionalContext: Record<string, unknown> = {}\n): void => {\n  // Determine the error message and stack based on the error type\n  let message: string;\n  let stack: string | undefined;\n\n  if (error instanceof Error) {\n    message = error.message;\n    stack = error.stack;\n  } else {\n    message = String(error); // Convert error to string if it's not an instance of Error\n    stack = undefined;\n  }\n\n  const errorLog: ErrorLog = {\n    message,\n    stack,\n    timestamp: new Date().toISOString(),\n    ...additionalContext\n  };\n\n  // Sentry.captureException(error, {\n  //   extra: errorLog\n  // });\n\n  console.error(errorLog);\n};\n","export const config = {\n  rust_api_url: 'https://api.rechat.cloud',\n  rust_ws_url: 'wss://api.rechat.cloud/ws',\n};","import { logError } from './logError';\nimport { config } from \"../config\";\n\nexport async function apiRequest<T>(\n  path: string,\n  fetchOptions: RequestInit = {},\n  serverOptions: { serverUrl?: string; cache?: boolean } = {}\n): Promise<T> {\n  const defaultHeaders = {\n    'Content-Type': 'application/json',\n  };\n\n  const { serverUrl = config.rust_api_url, } = serverOptions;\n  const url = `${serverUrl}${path}`;\n\n  try {\n\n    const response = await fetch(url, {\n      ...fetchOptions,\n      headers: {\n        ...defaultHeaders,\n        ...fetchOptions.headers,\n      },\n    });\n\n    const contentType = response.headers.get('content-type');\n\n    if (!response.ok) {\n      // if the response is not ok, and is not a json but and html, eg 502 errors\n      if (!contentType || !contentType.includes('application/json')) {\n        throw new Error(\n          `${url} <- Error ${response.status}: Invalid content-type. Expected application/json, got ${JSON.stringify(response.body)}`\n        );\n      }\n\n      const errorData = await response.json();\n\n\n      throw new Error(\n        `${url} <- Error ${response.status}: ${JSON.stringify(\n          errorData,\n          null,\n          2\n        )} `\n      );\n    }\n\n    if (response.status === 204) {\n      return { status: '204' } as T;\n    }\n\n    return (await response.json()) as T;\n  } catch (error) {\n    if (error instanceof Error) {\n      logErrorMetadata(error, url);\n    } else {\n      logError(error, { context: 'Unexpected Error', url });\n    }\n    throw error;\n  }\n}\n\nconst logErrorMetadata = (error: Error, url: string) => {\n  if (error.name === 'AbortError') {\n    logError(`Timeout – ${error.name} ${error}`, {\n      context: 'Timeout Error',\n      url\n    });\n  } else {\n    logError(`${error.name} ${error}`, { context: 'Fetch Error', url });\n  }\n};\n","import { apiRequest } from \"../lib/apiRequest\";\nimport { ChannelsResponseDto, MessageRequestDto, MessageResponseDto, MessagesResponseDto } from \"../types\";\n\n\nexport const fetchChannels = async () => {\n  return await apiRequest<{ data: ChannelsResponseDto, message: string }>(\n    '/api/channels',\n    {\n      method: \"GET\",\n      headers: {\n        Accept: 'application/json',\n      }\n    }\n  );\n}\n\nexport const createNewChannel = async ({ name }: { name: string }) => {\n  return await apiRequest<{ data: ChannelsResponseDto, message: string }>(\n    '/api/channels',\n    {\n      method: \"POST\",\n      headers: {\n        Accept: 'application/json',\n      },\n      body: JSON.stringify({ name })\n    },\n  );\n}\n\nexport const postMessage = async (message: MessageRequestDto) => {\n  return await apiRequest<{ data: MessageResponseDto, message: string }>(\n    '/api/messages',\n    {\n      method: \"POST\",\n      body: JSON.stringify(message)\n    },\n  );\n}\n\nexport const fetchMessagesByChannelId = async ({ channelId }: { channelId: string }) => {\n  return await apiRequest<{ data: MessagesResponseDto, message: string }>(\n    `/api/messages/${channelId}`,\n    {\n      method: \"GET\",\n      headers: {\n        Accept: 'application/json',\n      },\n    },\n  );\n}\n","import { useEffect, useRef, useState } from 'react';\nimport { config } from \"../../config\";\nimport { MessageRequestDto } from \"../../types\";\n\nexport function useWebSocket(channelName: string) {\n  const [isConnected, setIsConnected] = useState(false);\n  const [messages, setMessages] = useState<MessageRequestDto[]>([]);\n  const ws = useRef<WebSocket | null>(null);\n\n\n  useEffect(() => {\n    const connect = () => {\n      // Only create a new connection if there isn't one already\n      console.log(ws.current, ws.current?.readyState)\n      console.log('Connecting to WebSocket the ', channelName);\n      ws.current = new WebSocket(`${config.rust_ws_url}/chat/${channelName}`);\n\n      ws.current.onopen = () => {\n        setIsConnected(true);\n        console.log('WebSocket connected');\n      };\n\n      ws.current.onmessage = (event) => {\n        const data = JSON.parse(event.data);\n        setMessages(prev => [...prev, {\n          participant_id: data.participant_id,\n          channel_name: data.channel_name,\n          content: data.content,\n        }]);\n      };\n\n      ws.current.onclose = () => {\n        setIsConnected(false);\n        console.log('WebSocket closed');\n      };\n    };\n\n    connect();\n\n    // Cleanup function\n    return () => {\n      // Only close if connection exists and is open\n      if (ws.current && ws.current.readyState === WebSocket.OPEN) {\n        ws.current.close();\n      }\n    };\n  }, [channelName]);\n\n  return { isConnected, messages, ws: ws.current };\n}","import { useCallback, useEffect, useState } from 'react';\n\nimport { MessagesResponseDto } from \"../../types\";\nimport { fetchMessagesByChannelId } from \"../../services\";\n\nexport function useChannelMessages(channelId?: string) {\n  const [messages, setMessages] = useState<MessagesResponseDto>([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<Error | null>(null);\n\n  const fetchMessages = useCallback(async () => {\n    if (!channelId) return;\n\n    setIsLoading(true);\n    try {\n      const { data } = await fetchMessagesByChannelId({ channelId });\n      setMessages(data);\n    } catch (err) {\n      setError(err instanceof Error ? err : new Error('Failed to fetch messages'));\n    } finally {\n      setIsLoading(false);\n    }\n  }, [channelId]);\n\n  useEffect(() => {\n    fetchMessages();\n  }, [channelId, fetchMessages]);\n\n  return { messages, areMessagesLoading: isLoading, messagesError: error, refetchMessages: fetchMessages };\n}","'use client'\nimport * as React from 'react';\nimport { ChatListProps } from './types';\nimport { useChat } from \"../../context/ChatContext\";\n\nexport const ChannelList: React.FC<ChatListProps> = ({\n                                                    limit = 50,\n                                                    onChatSelect,\n                                                    customStyles = {},\n                                                    renderItem\n                                                  }) => {\n  const { channels } = useChat();\n\n  if (channels.isLoading) {\n    return <div>Loading chats...</div>;\n  }\n\n  return (\n    <div className={customStyles.container}>\n      {channels.data?.map((channel) => (\n        <div\n          key={channel.id}\n          onClick={() => onChatSelect?.(channel)}\n          className={customStyles.chatItem}\n        >\n          {renderItem ? (\n            renderItem(channel)\n          ) : (\n            <div>\n              <h3>{channel.name}</h3>\n            </div>\n          )}\n        </div>\n      ))}\n    </div>\n  );\n};","import * as React from 'react';\nimport { MessageInputProps } from './types';\nimport { useChat } from '../../context/ChatContext';\nimport { postMessage } from \"../../services\";\nimport { MessageRequestDto } from \"../../types\";\n\nexport const MessageInput: React.FC<MessageInputProps> = ({\n                                                            placeholder = 'Type a message...',\n                                                            onSend,\n                                                            maxLength = 1000,\n                                                            disabled = false,\n\n                                                          }) => {\n  const [message, setMessage] = React.useState('');\n  const {\n    ws,\n    currentUser: {\n      id: currentUserId,\n      isConnected\n    },\n    activeChannel: {\n      name: channelName\n    },\n  } = useChat();\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    if (message.trim() && ws && isConnected) {\n      const data = {\n        channel_name: channelName,\n        participant_id: currentUserId,\n        content: message,\n      } as MessageRequestDto\n\n      ws.send(JSON.stringify(data));\n\n      onSend?.(message);\n      setMessage('');\n\n      try {\n        await postMessage(data);\n      } catch (e) {\n        console.error(e);\n      }\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit} className=\"flex gap-2\">\n      <input\n        type=\"text\"\n        value={message}\n        onChange={(e) => setMessage(e.target.value)}\n        placeholder={placeholder}\n        maxLength={maxLength}\n        disabled={disabled || !isConnected}\n        className=\"flex-1 px-3 py-2 rounded border\"\n      />\n      <button\n        type=\"submit\"\n        disabled={disabled || !message.trim() || !isConnected}\n        className=\"px-4 py-2 rounded disabled:opacity-50\"\n      >\n        Send\n      </button>\n    </form>\n  );\n};","import * as React from 'react';\nimport { useEffect } from 'react';\nimport { MessagesProps } from './types';\nimport { useChat } from '../../context/ChatContext';\nimport { clsx } from \"clsx\";\nimport { PartialMessageRequestDto } from \"../../types\";\n\nexport const Messages: React.FC<MessagesProps> = ({\n                                                    className = '',\n                                                    containerClassName = '',\n                                                    messageClassName = '',\n                                                    renderMessage\n                                                  }) => {\n  const {\n    messages: { data: messages, refetch }, currentUser: {\n      id: currentUserId\n    },\n  } = useChat();\n  const messagesEndRef = React.useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    refetch()\n  }, []);\n\n  const scrollToBottom = () => {\n    messagesEndRef.current?.scrollIntoView({ behavior: \"smooth\" });\n  };\n\n  React.useEffect(() => {\n    scrollToBottom();\n  }, [messages]);\n\n\n  const defaultRenderMessage = (message: PartialMessageRequestDto) => {\n    return (\n      <div\n        key={message.participant_id.toString() + message.content}\n        className={clsx(\n          messageClassName,\n          'flex flex-col max-w-[70%]',\n          message.participant_id === currentUserId\n            ? 'ml-auto items-end'\n            : 'items-start'\n        )}\n      >\n      <span className=\"text-xs text-muted-foreground\">\n        {message.participant_id === currentUserId\n          ? ''\n          : message.participant_id ?? 'Some user'}\n      </span>\n        <div\n          className={clsx(\n            'rounded-lg px-1 max-w-[90%]',\n            message.participant_id === currentUserId\n              ? 'bg-blue-500 text-white self-end'\n              : 'bg-neutral-200 text-neutral-800 self-start'\n          )}\n        >\n          <p>{message.content}</p>\n        </div>\n      </div>)\n  };\n\n  return (\n    <div className={`flex flex-col h-full ${className}`}>\n      <div className={`flex-1 overflow-y-auto p-4 space-y-4 ${containerClassName}`}>\n        {messages?.map((message, index) => (\n          <div key={index} className=\"max-w-[70%]\">\n            {renderMessage ? renderMessage(message) : defaultRenderMessage(message)}\n          </div>\n        ))}\n        <div ref={messagesEndRef}/>\n      </div>\n    </div>\n  );\n};","function r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f)}else for(f in e)e[f]&&(n&&(n+=\" \"),n+=f);return n}export function clsx(){for(var e,t,f=0,n=\"\",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}export default clsx;"]}